# Usage for Code Metrics Engine

This application is compiled with **JDK 19**, please make sure your JRE is also 19 or higher.  
Please make sure your java files are encoded by Unicode. This Application do not support currently other encoding type such as ANSI.  
You can run this application through **CME.jar** in your terminal or through the project file in IDE

`java -jar CME.jar`

Then you'll get the menu page of the application.  

    Following functionalities are available:
    1. run Code Complexity check for given directory or file
    2. run Code Style check for given directory or file
    3. change current path
    0. exit


you will be led to input of **Path** based on current working directory.  
the path can either be a java file or a directory.  

``Please give the path:``

You will be asked to retry when following cases are encountered:
1. Path not found
2. the Path does not contain any java file
3. No methods from the Java files can be found
4. Exception occurred when accessing the file

Upon valid Path given, you can choose the functionalities by number.  

You can change the path by input 3, which will rescan the path for all the java file and their methods  
The menu is implemented to be able to repeat the task and change path through a loop. You can exit by input 0 or just close the terminal.  
After performing each task you chose, you will be shown again this menu.

## Example for invalid path

    Welcome to Code Metrics Engine
    Following functionalities are available:
    1. run Code Complexity check for given directory or file
    2. run Code Style check for given directory or file
    3. change current path
    0. exit
    Please give the path:
    D:\empty
    processing file...
    this file or directory dose not contain any of the java files
    D:\Jet Brain\CodeMetricsEngine\noMethods
    processing file...
    noMethods\123.java
    There are no methods detected, please choose another path
    D:\

## Example for Code Complexity
    D:\Testsfile/LinesOfCode.java
    
    6 method(s) detected!
    1. run Code Complexity check for given directory or file
    2. run Code Style check for given directory or file
    3. change current path
    0. exit
    Please choose the functionality with number:
    1
    methods with highest complexity(Worst Maintainability):
    [lineValidation]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 51
    with Complexity of: 42.05425073733029
    [calculate]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 29
    with Complexity of: 53.92049637408075
    [signatureOfMethod]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 93
    with Complexity of: 60.24239323751706

## Example for Code Style check for methods
    D:\Testsfile/LinesOfCode.java

    6 method(s) detected!
    1. run Code Complexity check for given directory or file
    2. run Code Style check for given directory or file
    3. change current path
    0. exit
    Please choose the functionality with number:
    2
    [GetPosition]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 21
    Name invalid!
    [lineVAlidation]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 51
    Name invalid!
    [signatureOfMEthod]  of class "LinesOfCode" in File "D:\Jet Brain\CodeMetricsEngine\Testsfile\LinesOfCode.java" : 93
    Name invalid!
    
    the percentage of invalid method name is: 50.0%

## Attention :

This application is based on AST generated from Compiler API from standard JDK after 1.8.  
If the given java file is compiled with error, the file with its path will be shown on Terminal.
the AST will still be generated by Compiler , which means we can still get the information about the methods within the file.  
the Statistics generated for this file may therefore be inaccurate!  

Please make sure your java files are free of compilation errors to gain maximal experience! 

### Example with compilation error
    D:\Error
    processing file...
    Error\alaram-clock.java
    
    Compilation error with file: file:///D:/Error/alaram-clock.java

    1 method(s) detected!
    1. run Code Complexity check for given directory or file
    2. run Code Style check for given directory or file
    3. change current path
    0. exit
    Please choose the functionality with number:
    1
    methods with highest complexity(Worst Maintainability):
    [main]  of class "AlarmClock" in File "D:\Jet Brain\CodeMetricsEngine\123\alaram-clock.java" : 8
    with Complexity of: 57.07882569574991

# Structure of this Application
This Application consist of various modules.  

**main.java** is the main entrance of the whole application and in charge of printing information and reading user input.  


**CodeComplexity** is the package that implements various key factors for Maintainability Index.  

**CodeStyle** contains implements for Code Style check, and currently only small Camelcase for methods.   
It can be extended with more metrics upon needs.

**Compiler** works for file compilation, AST generation and methods extraction from AST.  

in **IOSection** Utils.java realised multiple methods for user input, path validation.  
Methods.java is the abstract representation of methods read from AST, with its name, class name, position, path ,etc.  

# Implementation Process
## Code Complexity
During research, I found out multiple Complexity metrics for evaluation, and they tend to be combined for an objective criteria. Simply one metric for example Cyclomatic Complexity can lead to confusion for users, especially when it's not possible to reduce the number of branches.  
Therefore, I chose Maintainability Index for this application, which is already used by Microsoft for complexity.   
It is calculated based on following formula:  
`Maintainability Index = MAX(0,(171 - 5.2 * ln(Halstead Volume) - 0.23 * (Cyclomatic Complexity) - 16.2 * ln(Lines of Code))*100 / 171)`  
I personally find the coefficient for Lines of Code are a little bit high, but still need more evidence to adjust it.

## Code Style
I found out it is a much easier task when it comes to naming convention.  
In **Google Java Style Guide** there are several conventions for names of methods or class, as well as conventions for other functionalities such as formats.
I believe the modulariy of this application allows a simple extension for all other conventions, they are obviously not our greatest purpose for this project. Thus, I chose only to implement the part for naming convention of methods

**Either Code Complexity or Code Style requires a deep search into each method, which created a new problem for methods extraction from source file.**

## AST from compiler
When we try to extract every single methods from a source file, it is obscure to tell if a line is a method signature by processing each line of the file.  
A compiler which generates an AST is ideal for this purpose. 
Thanks to some discussion on Stackoverflow, I realised there exist a Compiler API with AST in standard JDK, which offered me a shortcut for recognition of methods in source file.  
I have also learned to use a TreeScanner which recursive traverses the whole AST given. It is applied when we try to find critical point with in a methods, such as if,loop etc.

## Implementation details for each functionality
After leaning about the Compiler API, I discovered that the life became much easier.   
for Cyclomatic Complexity, we apply a TreeScanner that detects branch node of each method.  
for Halsted Volume, we can also apply a Scanner to retrieve all the Literals or Identifiers ...  
for Lines of Code, it's much easier with knowing all the features of a method to identify the methods from line to line in a file. 
I applied a stack for {} to determine if a methods reaches to its end.  
for naming convention for methods, we can easily gain knowledge of the name of a methods from AST.

## Possible extensions 
More code metrics can be introduced and implemented in either Package (CodeComplexity, CodeStyle).  
By modifying the main() method in main.java, we can have a better menu for more functions.   
The methods are already retrieved in main() and stored in a static Arraylist in Utils for new metrics.
We can get from each "Methods" from this ArrayList its MethodTree for AST-based analysis or its path for Text-based analysis. 